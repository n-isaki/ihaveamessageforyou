rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper Functions
    function isAdmin() {
      return request.auth != null;
    }
    
    function isValidToken() {
      // Token validation via query parameter (for single document reads)
      return request.query.limit == 1 && 
             request.query.token != null &&
             resource.data.securityToken == request.query.token;
    }
    
    function isOwner() {
      // Check if user has valid token for this document
      // Token must match AND not be changed during update
      return request.resource.data.securityToken == resource.data.securityToken
             && request.resource.data.securityToken != null;
    }
    
    function hasValidTokenInUpdate() {
      // Check if the update includes a matching securityToken (sent from client)
      // This allows updates when token is validated client-side and included in update data
      return request.resource.data.securityToken == resource.data.securityToken
             && request.resource.data.securityToken != null;
    }
    
    function isLocked() {
      return resource.data.get('locked', false) == true;
    }
    
    function onlyAllowedFields(fields) {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(fields);
    }
    
    match /gift_orders/{documentId} {
      
      // READ: 
      // 1. Admin can always read (including unlocked gifts)
      // 2. With valid token (for setup links) - Note: Only works for queries, not getDoc()
      // 3. Locked gifts are publicly readable (for viewer links without token - PIN protects content client-side)
      // 4. Unlocked gifts are also readable (PIN validation happens client-side in Viewer)
      //    This allows viewing gifts before they are locked (e.g., during setup preview)
      allow read: if isAdmin() 
                  || isValidToken()
                  || isLocked()
                  || resource.data != null; // Allow reading any existing gift (PIN protects content client-side)
      
      // CREATE: Only Admin or Shopify Webhook (with shopifyOrderId)
      allow create: if isAdmin() 
                   || (request.resource.data.platform == 'shopify' 
                       && request.resource.data.shopifyOrderId != null)
                   || (request.resource.data.platform == 'etsy'
                       && request.resource.data.etsyOrderId != null);
      
      // UPDATE: 
      // 1. Admin can always update
      // 2. Setup Phase (NOT locked): Allow updates if token matches OR if only updating setupStarted/setupStartedAt
      // 3. Locked: Only 'viewed'/'viewedAt' can be updated
      // 4. Anyone can update 'viewed'/'viewedAt' (for viewer pages to mark as seen)
      allow update: if isAdmin()
                  || (!isLocked() 
                      && hasValidTokenInUpdate()
                      && onlyAllowedFields(['messages', 'headline', 'subheadline', 'locked', 
                                            'setupCompletedAt', 'setupStarted', 'setupStartedAt',
                                            'deceasedName', 'lifeDates', 'meaningText',
                                            'engravingText', 'meaningText', 'accessCode', 'securityToken']))
                  || (!isLocked() 
                      && onlyAllowedFields(['setupStarted', 'setupStartedAt'])) // ✅ Allow setupStarted updates without token (called from CustomerSetup after token validation)
                  || (!isLocked() 
                      && isOwner()
                      && onlyAllowedFields(['messages', 'headline', 'subheadline', 'locked', 
                                            'setupCompletedAt', 'setupStarted', 'setupStartedAt',
                                            'deceasedName', 'lifeDates', 'meaningText',
                                            'engravingText', 'meaningText', 'accessCode']))
                  || onlyAllowedFields(['viewed', 'viewedAt']); // ✅ Erlaube viewed/viewedAt Updates für alle (locked oder unlocked)
      
      // DELETE: Only Admin
      allow delete: if isAdmin();
    }
    
    // ============================================
    // KARAKEDIMARTIN - Separate Collections mit Prefix
    // ============================================
    
    match /karakedimartin_notes/{noteId} {
      // READ: Public notes are readable by everyone, private only by owner
      allow read: if resource.data.isPublic == true 
                  || isAdmin();
      
      // CREATE: Only authenticated users (you)
      allow create: if isAdmin();
      
      // UPDATE: Only owner (you)
      allow update: if isAdmin();
      
      // DELETE: Only owner (you)
      allow delete: if isAdmin();
    }
    
    match /karakedimartin_links/{linkId} {
      // READ: Public links are readable by everyone, private only by owner
      allow read: if resource.data.isPublic == true 
                  || isAdmin();
      
      // CREATE: Only authenticated users (you)
      allow create: if isAdmin();
      
      // UPDATE: Only owner (you)
      allow update: if isAdmin();
      
      // DELETE: Only owner (you)
      allow delete: if isAdmin();
    }
    
    match /karakedimartin_collections/{collectionId} {
      // READ: Public collections are readable by everyone, private only by owner
      allow read: if resource.data.isPublic == true 
                  || isAdmin();
      
      // CREATE: Only authenticated users (you)
      allow create: if isAdmin();
      
      // UPDATE: Only owner (you)
      allow update: if isAdmin();
      
      // DELETE: Only owner (you)
      allow delete: if isAdmin();
    }
  }
}
